
# Sistemas de Banco de Dados — Resumo (baseado em Elmasri & Navathe, 7ª ed.)

> **Obs.**: Este material foi elaborado para as aulas de *Sistemas de Banco de Dados* e se baseia nos conceitos clássicos de modelagem e design apresentados em Elmasri & Navathe (7ª edição).

---

## Sumário
1. Objetivo
2. Cenário (Minimundo): Relatório de Despesas Pessoais
3. Modelagem conceitual e relações (Entidades, Atributos, Chaves)
4. DDL — `CREATE TABLE` (PostgreSQL) com exemplos
5. DML — `INSERT`, `UPDATE`, `DELETE` e `UPDATE` com cálculos e arredondamento
6. Consultas de recuperação SQL — `SELECT` e cláusulas (expressões, `FROM`, `WHERE`, `GROUP BY`, `HAVING`, `ORDER BY`, `LIMIT`)
7. Operadores aritméticos e funções ( `+`, `-`, `*`, `/`, `%` / `mod()` )
8. `LIKE`, `IN`, `AND`, `OR`, `NULL` e tratamento de strings
9. `COUNT`, `COUNT(DISTINCT)` e outras agregações
10. Joins: `INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN` — exemplos e explicações
11. Subclasses / Superclasses / Herança — mapeamento para tabelas relacionais
12. Especialização / Generalização — conceitos e estratégias de implementação
13. Normalização: 1NF, 2NF, 3NF, BCNF com exemplos; `ALTER TABLE` e colunas calculadas
14. Exercícios práticos (enunciados) e Gabarito

---

## 1 — Objetivo

Este material tem o objetivo de:
- Explicar os conceitos fundamentais de modelagem relacional (entidades, atributos, chaves).
- Mostrar a criação e manipulação de tabelas em SQL (PostgreSQL).
- Desenvolver consultas progressivas, desde `SELECT *` até consultas com agregação e joins.
- Tratar de normalização e de como representar herança (subclasses/superclasses) no modelo relacional.
- Fornecer um conjunto de exercícios com gabarito para estudo e avaliação.

---

## 2 — Cenário (Minimundo): Relatório de Despesas Pessoais

**Descrição:** um sistema simples que registra lançamentos de despesas, suas categorias e a forma de pagamento.

Tabelas principais:
- `categorias` (dimensão)
- `formas_pagamento` (dimensão)
- `lancamentos` (fato)

### Entidades e atributos (resumo)
- `categorias`:
  - `categoria_id` (INT) — PK
  - `nome` (VARCHAR) — ex: "Alimentação", "Energia", "Água"

- `formas_pagamento`:
  - `forma_pagamento_id` (INT) — PK
  - `nome` (VARCHAR) — ex: "Cartão de Crédito", "PIX", "Dinheiro"

- `lancamentos`:
  - `lancamento_id` (INT) — PK
  - `descricao` (VARCHAR)
  - `valor` (DECIMAL/NUMERIC)
  - `data_lancamento` (DATE)
  - `categoria_id` (FK → categorias.categoria_id)
  - `forma_pagamento_id` (FK → formas_pagamento.forma_pagamento_id)

Diagrama conceitual simples:  
`categorias (1) <-- (N) lancamentos (N) --> (1) formas_pagamento`

---

## 3 — Modelagem: Conjuntos de entidades, Atributos e Chaves

**Conjunto de entidades** = conjunto de instâncias de um mesmo tipo (ex.: todos os registros de `lancamentos`).  
**Atributo** = propriedade de uma entidade (ex.: `valor`, `descricao`).  
**Chave** = conjunto de atributos que identificam unicamente uma entidade no conjunto (PK).

Regras importantes:
- Escolha PKs estáveis e imutáveis sempre que possível (um `id` auto-incremento é padrão prático).
- Use FKs para manter integridade referencial entre tabelas.
- Declare constraints (`NOT NULL`, `UNIQUE`, `CHECK`) para capturar regras de negócio no nível do banco.

---

## 4 — DDL: `CREATE TABLE` (exemplos em PostgreSQL)

```sql
-- Criação da tabela de categorias
CREATE TABLE IF NOT EXISTS categorias (
    categoria_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    descricao TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
    CONSTRAINT uq_categorias_nome UNIQUE (nome),
    CONSTRAINT ck_categorias_nome_nao_vazio CHECK (char_length(trim(nome)) > 0)
);

-- Criação da tabela de formas de pagamento
CREATE TABLE IF NOT EXISTS formas_pagamento (
    forma_pagamento_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    codigo_externo VARCHAR(50), -- opcional: código usado por sistemas de pagamento
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
    CONSTRAINT uq_formas_pagamento_nome UNIQUE (nome),
    CONSTRAINT ck_formas_pagamento_nome_nao_vazio CHECK (char_length(trim(nome)) > 0)
);

-- Criação da tabela de lançamentos (fato)
CREATE TABLE IF NOT EXISTS lancamentos (
    lancamento_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    descricao TEXT,
    valor NUMERIC(12,2) NOT NULL,
    data_lancamento DATE NOT NULL,
    categoria_id INT NOT NULL,
    forma_pagamento_id INT NOT NULL,
    observacao TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
    -- Constraints / integridade
    CONSTRAINT ck_lancamentos_valor_nao_negativo CHECK (valor >= 0),
    CONSTRAINT fk_lancamentos_categoria FOREIGN KEY (categoria_id)
        REFERENCES categorias (categoria_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    CONSTRAINT fk_lancamentos_forma_pagamento FOREIGN KEY (forma_pagamento_id)
        REFERENCES formas_pagamento (forma_pagamento_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT
);

-- Índices em colunas de FK para melhorar desempenho de joins/consultas
CREATE INDEX IF NOT EXISTS idx_lancamentos_categoria_id ON lancamentos (categoria_id);
CREATE INDEX IF NOT EXISTS idx_lancamentos_forma_pagamento_id ON lancamentos (forma_pagamento_id);

-- (Opcional) Índice composto para consultas por data e valor (ex.: relatórios)
CREATE INDEX IF NOT EXISTS idx_lancamentos_data_valor ON lancamentos (data_lancamento, valor);

---
```
**Comentários:**
- INT GENERATED BY DEFAULT AS IDENTITY: substitui SERIAL, é padrão SQL mais moderno e evita problemas de sequência ao replicar/ler DDL.
- CHAR_LENGTH(TRIM(nome)) > 0 nas CHECK evita nomes vazios ou apenas com espaços.
- NUMERIC(12,2) para valores financeiros: precisão controlada, evita erros de ponto flutuante.
- ON UPDATE CASCADE em FKs: mantém consistência caso ids sejam remapeados; ON DELETE RESTRICT evita exclusão de categorias/formas em uso. Ajuste conforme regra de negócio (por exemplo SET NULL se preferir permitir exclusões).
- created_at TIMESTAMP WITH TIME ZONE DEFAULT now(): útil para auditoria (quem/quando inseriu, sem depender do aplicativo).
- Índices em FKs: melhoram desempenho de JOINs e de filtros por categoria/forma.

## 5 — DML: `INSERT`, `UPDATE`, `DELETE` (exemplos e explicações)

### Inserir dados
```sql
-- Inserir categorias
INSERT INTO categorias (nome) VALUES
('Alimentação'),
('Transporte'),
('Energia Elétrica'),
('Água'),
('Internet');

-- Inserir formas de pagamento
INSERT INTO formas_pagamento (nome) VALUES
('PIX'),
('Cartão de Crédito'),
('Débito'),
('Dinheiro');

-- Inserir lançamentos (exemplos)
INSERT INTO lancamentos (descricao, valor, data_lancamento, categoria_id, forma_pagamento_id) VALUES
('Supermercado - Mercadão', 250.75, '2025-10-01', 1, 2),
('Conta de Luz - CEMIG', 120.40, '2025-09-25', 3, 3),
('Assinatura Internet', 99.90, '2025-09-30', 5, 2),
('Táxi aeroporto', 68.00, '2025-10-02', 2, 1);
```

### Atualizar (`UPDATE`) — cenários e cálculos
Atualizar um valor com acréscimo percentual (ex.: ajuste inflacionário de 5%) e arredondar para 2 casas decimais:

```sql
UPDATE lancamentos
SET valor = ROUND(valor * 1.05, 2)
WHERE data_lancamento < '2025-10-01';
```

Explicação:
- `ROUND(expr, 2)` arredonda o resultado para duas casas decimais (PostgreSQL).

Outro exemplo: aplicar desconto por forma de pagamento:

```sql
-- Desconto de 2% para pagamentos em 'PIX'
UPDATE lancamentos l
SET valor = ROUND(l.valor * 0.98, 2)
FROM formas_pagamento f
WHERE l.forma_pagamento_id = f.forma_pagamento_id
  AND f.nome = 'PIX';
```

### Deletar (`DELETE`)

```sql
-- Remover lançamentos de teste
DELETE FROM lancamentos
WHERE descricao ILIKE '%teste%';
```

**Dica de segurança:** prefira sempre executar um `SELECT` com a mesma `WHERE` antes de `DELETE` para verificar quais linhas serão afetadas.

---

## 6 — `SELECT`: recuperação básica e progressiva

### Sintaxe básica

```sql
SELECT <colunas ou expressões>
FROM <tabela> -- ou JOINs
[WHERE <condição>]
[GROUP BY <colunas>]
[HAVING <condição de grupo>]
[ORDER BY <colunas> [ASC|DESC]]
[LIMIT n];
```

### Exemplos iniciais com nosso cenário

1. Listar descrição, valor e data de todos os lançamentos:

```sql
SELECT descricao, valor, data_lancamento
FROM lancamentos;
```

2. Mostrar lançamentos com valor > 100:

```sql
SELECT descricao, valor, data_lancamento
FROM lancamentos
WHERE valor > 100.00;
```

3. Descrição de cada lançamento e o nome da sua categoria (JOIN):

```sql
SELECT l.descricao, c.nome AS categoria, l.valor, l.data_lancamento
FROM lancamentos l
JOIN categorias c ON l.categoria_id = c.categoria_id;
```

4. Descrição, valor, categoria e forma de pagamento:

```sql
SELECT l.descricao, l.valor, c.nome AS categoria, f.nome AS forma_pagamento
FROM lancamentos l
JOIN categorias c ON l.categoria_id = c.categoria_id
JOIN formas_pagamento f ON l.forma_pagamento_id = f.forma_pagamento_id;
```

---

## 7 — Operações aritméticas no `SELECT` (`+`, `-`, `*`, `/`, `mod()`)

Exemplos:

```sql
-- Mostrar valor, imposto de 8% e total com imposto
SELECT descricao, valor,
       valor * 0.08 AS imposto,
       ROUND(valor * 1.08, 2) AS valor_com_imposto
FROM lancamentos;

-- Dividir valor em 3 parcelas
SELECT descricao, valor, ROUND(valor / 3.0, 2) AS parcela_3x
FROM lancamentos;

-- Resto da divisão por 10 (mod)
SELECT descricao, valor, mod(valor, 10) AS resto_por_10
FROM lancamentos;
```

**Nota importante:** use `ROUND(..., 2)` para valores monetários ao mostrar/atualizar preços.

---

## 8 — `WHERE`: `AND`, `OR`, `IN`, `LIKE`, tratamento de `NULL`

### Exemplos

```sql
-- Combinação AND / OR
SELECT * FROM lancamentos
WHERE (categoria_id = 1 OR categoria_id = 5)
  AND valor > 50;

-- Usando IN
SELECT * FROM lancamentos
WHERE categoria_id IN (1,2,3);

-- LIKE (case-insensitive em PostgreSQL usando ILIKE)
SELECT * FROM lancamentos
WHERE descricao ILIKE '%supermercado%';

-- Verificar NULL
SELECT * FROM lancamentos
WHERE forma_pagamento_id IS NULL;
```

**Explicação:**
- `AND` exige que todas as condições sejam verdadeiras.
- `OR` aceita qualquer uma verdadeira.
- Parênteses controlam precedência lógica.
- `IN` é equivalente a várias ORs, porém mais legível.
- `LIKE` compara padrões; `ILIKE` em PostgreSQL ignora maiúsculas/minúsculas.

---

## 9 — `ORDER BY`, `LIMIT`, alias e uso de alias

```sql
-- Top 5 lançamentos por valor
SELECT descricao, valor
FROM lancamentos
ORDER BY valor DESC
LIMIT 5;

-- Alias (apelido) e uso em ORDER BY
SELECT descricao AS desc_lanc, valor AS valor_bruto
FROM lancamentos
ORDER BY valor_bruto DESC;
```

**Observação sobre aliases e GROUP BY:** em muitos SGBDs não é possível usar o alias do `SELECT` em `GROUP BY`/`HAVING` na mesma expressão lógica — use subquery/CTE para isso.

---

## 10 — `GROUP BY`, `HAVING`, `COUNT` e agregações

### Contagem de lançamentos por categoria

```sql
SELECT c.nome AS categoria,
       COUNT(*) AS numero_lancamentos,
       SUM(l.valor) AS total_gasto,
       AVG(l.valor) AS media_gasto
FROM lancamentos l
JOIN categorias c ON l.categoria_id = c.categoria_id
GROUP BY c.nome
ORDER BY total_gasto DESC;
```

### `COUNT(DISTINCT)`

```sql
-- Quantas formas de pagamento distintas foram usadas
SELECT COUNT(DISTINCT forma_pagamento_id) AS formas_usadas
FROM lancamentos;
```

### `HAVING` — filtrar grupos

```sql
-- Mostrar categorias com gasto total maior que 500
SELECT c.nome AS categoria, SUM(l.valor) AS total_gasto
FROM lancamentos l
JOIN categorias c ON l.categoria_id = c.categoria_id
GROUP BY c.nome
HAVING SUM(l.valor) > 500;
```

---

## 11 — `LIKE`, `ORDER BY`, `LIMIT`, `GROUP BY` / `HAVING` — exemplos compostos

```sql
-- Consultas combinadas: lançamentos de 'Conta' (descrição) por categoria, ordenados
SELECT c.nome, l.descricao, l.valor
FROM lancamentos l
JOIN categorias c ON l.categoria_id = c.categoria_id
WHERE l.descricao ILIKE '%conta%'
ORDER BY c.nome, l.valor DESC
LIMIT 20;
```

---

## 12 — Exemplos de `INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN` — explicações e diferenças

### `INNER JOIN`
Retorna apenas linhas que têm correspondência em ambas as tabelas.

```sql
-- Ex.: lançamentos com sua categoria (apenas quando existir a categoria)
SELECT l.lancamento_id, l.descricao, c.nome AS categoria
FROM lancamentos l
INNER JOIN categorias c ON l.categoria_id = c.categoria_id;
```

### `LEFT JOIN` (ou `LEFT OUTER JOIN`)
Retorna todas as linhas da tabela à esquerda e adiciona NULLs quando não há correspondência na tabela à direita.

```sql
-- Ex.: todos os lançamentos, e quando a categoria não existir (ou estiver vazia) mostrar NULL
SELECT l.lancamento_id, l.descricao, c.nome AS categoria
FROM lancamentos l
LEFT JOIN categorias c ON l.categoria_id = c.categoria_id;
```

Uso prático: encontrar lançamentos sem categoria associada:

```sql
SELECT l.*
FROM lancamentos l
LEFT JOIN categorias c ON l.categoria_id = c.categoria_id
WHERE c.categoria_id IS NULL;
```

### `RIGHT JOIN`
Semelhante ao LEFT JOIN, mas preserva linhas da tabela à direita. Em bancos onde RIGHT JOIN é raro, prefira inverter a ordem e usar LEFT JOIN.

---

## 13 — SubClasses, SuperClasses e Herança (conceitos e mapeamento relacional)

No modelo conceitual (ER), podemos ter uma entidade genérica (superclasse) e especializações (subclasses). Exemplos do mundo real: `Pessoa` → (`Paciente`, `Medico`).

### Estratégias de mapeamento para o modelo relacional

1. **Table per Hierarchy (Single Table Inheritance)**  
   Uma tabela única com colunas comuns e colunas específicas opcionais + coluna discriminadora.

   ```sql
   CREATE TABLE pessoa_unica (
     pessoa_id SERIAL PRIMARY KEY,
     nome TEXT,
     tipo VARCHAR(20) NOT NULL, -- 'PACIENTE' | 'MEDICO'
     crm VARCHAR(50),           -- só para medico
     data_nascimento DATE,      -- só para paciente
     -- outros campos...
     CHECK (tipo IN ('PACIENTE','MEDICO'))
   );
   ```

   **Vantagens:** simplicidade, performance de leitura.  
   **Desvantagens:** muitas colunas NULL, complexidade para constraints específicas.

2. **Table per Class (Class Table Inheritance)**  
   Uma tabela para a superclasse e uma tabela para cada subclasse que referencia a superclasse.

   ```sql
   CREATE TABLE pessoa (
     pessoa_id SERIAL PRIMARY KEY,
     nome TEXT NOT NULL
   );

   CREATE TABLE medico (
     pessoa_id INT PRIMARY KEY REFERENCES pessoa(pessoa_id),
     crm VARCHAR(50) NOT NULL UNIQUE,
     especialidade VARCHAR(100)
   );

   CREATE TABLE paciente (
     pessoa_id INT PRIMARY KEY REFERENCES pessoa(pessoa_id),
     data_nascimento DATE,
     convenio VARCHAR(100)
   );
   ```

   **Vantagens:** normalização, sem colunas NULL para campos específicos.  
   **Desvantagens:** leituras exigem `JOIN` entre tabela base e subclasse.

3. **Table per Concrete Class (Concrete Table Inheritance)**  
   Cada subclasse tem sua própria tabela com **todos** os atributos (incluindo os da superclasse).

   ```sql
   CREATE TABLE medico_concreto (
     medico_id SERIAL PRIMARY KEY,
     nome TEXT NOT NULL,
     crm VARCHAR(50) NOT NULL UNIQUE
     -- outros campos repetidos...
   );

   CREATE TABLE paciente_concreto (
     paciente_id SERIAL PRIMARY KEY,
     nome TEXT NOT NULL,
     data_nascimento DATE
   );
   ```

   **Vantagens:** simples para consultas nativas da subclasse.  
   **Desvantagens:** duplicação de dados e inconsistência potencial.

**Recomendação (acadêmica / prática):** Table per Class (2) é a mais usada quando é importante evitar nulidade e manter integridade; Table per Hierarchy (1) é útil para protótipos ou quando consultas cruzadas são frequentes.

---

## 14 — Especialização e Generalização

- **Generalização:** agrupar entidades similares em uma superclasse comum (ex.: `Veiculo` generaliza `Carro` e `Moto`).
- **Especialização:** dividir uma superclasse em subclasses de acordo com propriedades específicas.

**Pontos a observar:**
- A decisão de especializar depende de restrições e regras de negócio.
- Em modelagem, defina se a especialização é **disjunta** (um indivíduo pertence a no máximo uma subclasse) ou **sobreposta** (pode pertencer a várias).
- Defina se a especialização é **total** (todo membro da superclasse pertence a alguma subclasse) ou **parcial**.

Ao implementar em SQL, escolha uma das estratégias de mapeamento discutidas na seção anterior.

---

## 15 — Normalização (1NF, 2NF, 3NF, BCNF) com exemplos

**1NF (Primeira Forma Normal):**
- Cada célula da tabela deve conter um único valor atômico (sem listas ou arrays).
- Exemplo de violação: coluna `telefones` contendo '["(31)9999-9999","(31)9888-8888"]'. Em 1NF, separe em `telefone` tabela ou linhas.

**2NF (Segunda Forma Normal):**
- Estar em 1NF e todos os atributos não-chave devem depender **totalmente** da chave primária.
- Relevante apenas quando PK é composta. Ex.: `venda_item(venda_id, produto_id, produto_preco, venda_data)` — `venda_data` depende apenas de `venda_id`, não da chave completa; separar `vendas` e `venda_itens`.

**3NF (Terceira Forma Normal):**
- Estar em 2NF e não haver dependências transitivas entre atributos não-chave.
- Ex.: `cliente(id, cidade, estado, pais)`, se `estado` depende de `pais`, pode examinar se precisa normalizar.

**BCNF (Forma Normal de Boyce-Codd):**
- Versão mais forte da 3NF; elimina anomalias quando existem dependências funcionais não-triviais.

### Exemplo prático de normalização no nosso cenário

Imaginemos que inicialmente tenhamos uma tabela `lancamentos_extra` com `descricao, valor, data, categoria_nome, forma_pagamento_nome`. Para normalizar:
1. Extrair `categorias` (1NF/3NF).
2. Extrair `formas_pagamento`.
3. Usar `categoria_id` e `forma_pagamento_id` em `lancamentos`.

---

## 16 — `ALTER TABLE` e colunas calculadas

Exemplos de alteração de estrutura:

```sql
-- Adicionar coluna de observação
ALTER TABLE lancamentos ADD COLUMN observacao TEXT;

-- Mudar tipo de coluna (atenção com dados existentes)
ALTER TABLE lancamentos ALTER COLUMN valor TYPE NUMERIC(14,2);

-- Adicionar constraint UNIQUE
ALTER TABLE categorias ADD CONSTRAINT uq_categoria_nome UNIQUE (nome);
```

### Coluna calculada (PostgreSQL)
PostgreSQL suporta *generated columns* em versões mais recentes:

```sql
-- Coluna gerada (exemplo hipotético): valor_com_imposto gerado automaticamente
ALTER TABLE lancamentos
ADD COLUMN valor_com_imposto NUMERIC(14,2)
  GENERATED ALWAYS AS (ROUND(valor * 1.08, 2)) STORED;
```

Se seu SGBD não suportar colunas geradas armazenadas, use `VIEW`:

```sql
CREATE VIEW lancamentos_com_imposto AS
SELECT l.*, ROUND(l.valor * 1.08, 2) AS valor_com_imposto
FROM lancamentos l;
```

---

## 17 — Exemplos avançados e padrões úteis

### Subquery correlacionada (ex.: marcar lançamentos acima da média da categoria)

```sql
SELECT l.*
FROM lancamentos l
WHERE l.valor > (
  SELECT AVG(l2.valor)
  FROM lancamentos l2
  WHERE l2.categoria_id = l.categoria_id
);
```

### CTE (Common Table Expression) — legibilidade

```sql
WITH gastos_por_categoria AS (
  SELECT categoria_id, SUM(valor) AS total_gasto
  FROM lancamentos
  GROUP BY categoria_id
)
SELECT c.nome, g.total_gasto
FROM gastos_por_categoria g
JOIN categorias c ON c.categoria_id = g.categoria_id
ORDER BY g.total_gasto DESC;
```

---

## 18 — Exercícios práticos (enunciados)

Use a base com as três tabelas (`categorias`, `formas_pagamento`, `lancamentos`) e dados de exemplo.

1. Liste a `descricao`, `valor` e `data_lancamento` de todos os lançamentos.
2. Mostre apenas os lançamentos com `valor > 100`.
3. Liste a `descricao` de cada lançamento e o `nome` da sua `categoria`.
4. Mostre `descricao`, `valor`, `categoria` e `forma de pagamento` para todos os lançamentos (duas joins).
5. Qual o valor total gasto por `categoria`?
6. Quanto foi gasto no total usando "Cartão de Crédito"?
7. Quais lançamentos (descricao e valor) foram pagos com "PIX" e são da categoria "Alimentação"?
8. Atualize todos os lançamentos anteriores a `2025-10-01`, aplicando correção de 4%, arredondando para 2 casas.
9. Crie uma `VIEW` que retorne `descricao`, `valor`, `categoria` e `valor_com_imposto` (8%).
10. Liste as 5 maiores despesas (descrição, valor, categoria).
11. Identifique categorias com gasto total maior que 1000 (use `HAVING`).
12. Conte quantas formas de pagamento diferentes foram usadas por categoria.
13. Encontre lançamentos cujo `descricao` contenha "conta" (case-insensitive).
14. Escreva uma query que retorne todas as categorias, incluindo aquelas sem lançamentos (use `LEFT JOIN`).
15. Modele a situação onde `Pessoa` pode ser `Cliente` e `Fornecedor` (mostre SQL para criação das tabelas no padrão Table per Class).

---

## 19 — Gabarito (soluções exemplares)

1)
```sql
SELECT descricao, valor, data_lancamento FROM lancamentos;
```

2)
```sql
SELECT descricao, valor FROM lancamentos WHERE valor > 100.00;
```

3)
```sql
SELECT l.descricao, c.nome AS categoria
FROM lancamentos l
JOIN categorias c ON l.categoria_id = c.categoria_id;
```

4)
```sql
SELECT l.descricao, l.valor, c.nome AS categoria, f.nome AS forma_pagamento
FROM lancamentos l
JOIN categorias c ON l.categoria_id = c.categoria_id
JOIN formas_pagamento f ON l.forma_pagamento_id = f.forma_pagamento_id;
```

5)
```sql
SELECT c.nome AS categoria, SUM(l.valor) AS total_gasto
FROM lancamentos l
JOIN categorias c ON l.categoria_id = c.categoria_id
GROUP BY c.nome
ORDER BY total_gasto DESC;
```

6)
```sql
SELECT SUM(l.valor) AS total_cartao_credito
FROM lancamentos l
JOIN formas_pagamento f ON l.forma_pagamento_id = f.forma_pagamento_id
WHERE f.nome = 'Cartão de Crédito';
```

7)
```sql
SELECT l.descricao, l.valor
FROM lancamentos l
JOIN categorias c ON l.categoria_id = c.categoria_id
JOIN formas_pagamento f ON l.forma_pagamento_id = f.forma_pagamento_id
WHERE f.nome = 'PIX' AND c.nome = 'Alimentação';
```

8)
```sql
BEGIN;
UPDATE lancamentos
SET valor = ROUND(valor * 1.04, 2)
WHERE data_lancamento < '2025-10-01';
COMMIT;
```

9) `VIEW` com imposto 8%
```sql
CREATE OR REPLACE VIEW vw_lancamentos_imposto AS
SELECT l.*, ROUND(l.valor * 1.08, 2) AS valor_com_imposto,
       c.nome AS categoria, f.nome AS forma_pagamento
FROM lancamentos l
JOIN categorias c ON l.categoria_id = c.categoria_id
JOIN formas_pagamento f ON l.forma_pagamento_id = f.forma_pagamento_id;
```

10)
```sql
SELECT l.descricao, l.valor, c.nome AS categoria
FROM lancamentos l
JOIN categorias c ON l.categoria_id = c.categoria_id
ORDER BY l.valor DESC
LIMIT 5;
```

11)
```sql
SELECT c.nome, SUM(l.valor) AS total_gasto
FROM lancamentos l
JOIN categorias c ON l.categoria_id = c.categoria_id
GROUP BY c.nome
HAVING SUM(l.valor) > 1000;
```

12)
```sql
SELECT c.nome AS categoria, COUNT(DISTINCT l.forma_pagamento_id) AS formas_distintas
FROM lancamentos l
JOIN categorias c ON l.categoria_id = c.categoria_id
GROUP BY c.nome;
```

13)
```sql
SELECT descricao, valor, data_lancamento
FROM lancamentos
WHERE descricao ILIKE '%conta%';
```

14)
```sql
SELECT c.nome AS categoria, SUM(l.valor) AS total_gasto
FROM categorias c
LEFT JOIN lancamentos l ON l.categoria_id = c.categoria_id
GROUP BY c.nome
ORDER BY total_gasto DESC NULLS LAST;
```

15) Exemplo Table per Class (Pessoa / Cliente / Fornecedor)
```sql
CREATE TABLE pessoa (
  pessoa_id SERIAL PRIMARY KEY,
  nome TEXT NOT NULL,
  cpf VARCHAR(11) UNIQUE
);

CREATE TABLE cliente (
  pessoa_id INT PRIMARY KEY REFERENCES pessoa(pessoa_id),
  data_cadastro DATE,
  tipo_cliente VARCHAR(50)
);

CREATE TABLE fornecedor (
  pessoa_id INT PRIMARY KEY REFERENCES pessoa(pessoa_id),
  cnpj VARCHAR(14) UNIQUE,
  contato TEXT
);
```

---

## 20 — Boas práticas e observações para prova

- Entenda a **ordem lógica** de execução de um `SELECT`: `FROM` → `WHERE` → `GROUP BY` → `HAVING` → `SELECT` → `ORDER BY` → `LIMIT`.
- Use **CTEs** para tornar consultas complexas mais legíveis.
- Prefira declarar constraints (FK, CHECK, UNIQUE) no DDL — tornam o modelo mais robusto.
- Use tipos numéricos (`NUMERIC`/`DECIMAL`) para valores monetários; evite `FLOAT` para cálculos financeiros.
- Ao atualizar valores em lote, rode primeiro um `SELECT` com a mesma cláusula `WHERE`, e rode dentro de uma transação para poder `ROLLBACK`.
- Para modelagem de herança, saiba as três estratégias e justifique sua escolha.

---

## 21 — Referências

- Elmasri, R.; Navathe, S. *Fundamentals of Database Systems*, 7th Edition (material conceitual base).
