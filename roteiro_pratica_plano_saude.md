# Roteiro de Prática — Revisão e Melhoria do Banco de Dados `plano_saude`

---

## 1 Objetivo

Esta prática tem como finalidade capacitar você a analisar, propor e aplicar melhorias em um schema relacional já existente (PostgreSQL). Você irá:

- Identificar problemas de modelagem e integridade
- Normalizar atributos (endereços, especialidades)
- Corrigir tipos de dados e máscaras
- Adicionar constraints (`NOT NULL`, `UNIQUE`, `CHECK`, `FOREIGN KEY`) e índices quando necessários
- Escrever queries para validar as alterações

Ao final, você deverá apresentar os ajustes realizados ao professor e enviar um relatório final com prints que mostrem cada passo executado (comandos SQL e outputs) para que a atividade possa ser analisada.

---

## 2 Script original (para referência)

- Script SQL completo para criar o banco e popular com dados de exemplo
- 15 registros de pacientes
- 6 registros de médicos
- 20 registros de consultas
- 4 pacientes sem consultas
- 2 médicos sem atendimentos

### 2.1 Criar o banco e conectar

```sql
-- criar o banco
CREATE DATABASE plano_saude;
```

### 2.2 Estrutura inicial (schema)

```sql
-- tabela base: pessoa
CREATE TABLE pessoa (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome text NOT NULL,
  cpf varchar(14) UNIQUE,
  data_nascimento date,
  telefone text,
  email text,
  endereco text
);

-- paciente herda (sem duplicar) os dados de pessoa via referência
CREATE TABLE paciente (
  pessoa_id int PRIMARY KEY REFERENCES pessoa(id) ON DELETE CASCADE,
  numero_cartao varchar(30),
  data_cadastro date
);

-- medico herda os dados de pessoa via referência
CREATE TABLE medico (
  pessoa_id int PRIMARY KEY REFERENCES pessoa(id) ON DELETE CASCADE,
  crm varchar(20) UNIQUE,
  especialidade text
);

-- tabela associativa consulta com id próprio para permitir múltiplas consultas
CREATE TABLE consulta (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  paciente_id int NOT NULL REFERENCES paciente(pessoa_id) ON DELETE RESTRICT,
  medico_id int NOT NULL REFERENCES medico(pessoa_id) ON DELETE RESTRICT,
  data_consulta timestamp NOT NULL,
  observacoes text
);

-- índices para performance em joins e buscas por data
CREATE INDEX idx_consulta_paciente ON consulta(paciente_id);
CREATE INDEX idx_consulta_medico ON consulta(medico_id);
CREATE INDEX idx_consulta_data ON consulta(data_consulta);
```

### 2.3 Inserir os dados (15 pacientes, 6 médicos, 20 consultas)

> Observação: o script original insere `pessoa` com ids explícitos. Como `id` foi definido como `GENERATED BY DEFAULT AS IDENTITY`, inserir valores explícitos é permitido, porém deve-se ter cuidado ao misturar inserções manuais e valores gerados automaticamente em ambientes reais.

```sql
-- inserindo 15 pacientes (ids 1 a 15)
INSERT INTO pessoa(id, nome, cpf, data_nascimento, telefone, email, endereco) VALUES
(1, 'João Silva', '111.111.111-11', '1980-03-10', '11 9999-0001', 'joao.silva@example.com', 'Rua A, 100'),
(2, 'Maria Souza', '222.222.222-22', '1990-07-25', '11 9999-0002', 'maria.souza@example.com', 'Rua B, 200'),
(3, 'José Santos', '333.333.333-33', '1975-01-30', '11 9999-0003', 'jose.santos@example.com', 'Rua C, 300'),
(4, 'Ana Oliveira', '444.444.444-44', '1985-11-05', '11 9999-0004', 'ana.oliveira@example.com', 'Rua D, 400'),
(5, 'Carlos Pereira', '555.555.555-55', '1992-02-18', '11 9999-0005', 'carlos.pereira@example.com', 'Rua E, 500'),
(6, 'Fernanda Lima', '666.666.666-66', '1988-06-12', '11 9999-0006', 'fernanda.lima@example.com', 'Rua F, 600'),
(7, 'Ricardo Almeida', '777.777.777-77', '1979-09-01', '11 9999-0007', 'ricardo.almeida@example.com', 'Rua G, 700'),
(8, 'Patrícia Rodrigues', '888.888.888-88', '1995-12-22', '11 9999-0008', 'patricia.rodrigues@example.com', 'Rua H, 800'),
(9, 'Bruno Costa', '999.999.999-99', '1991-04-14', '11 9999-0009', 'bruno.costa@example.com', 'Rua I, 900'),
(10, 'Juliana Carvalho', '101.101.101-10', '1983-08-30', '11 9999-0010', 'juliana.carvalho@example.com', 'Rua J, 1000'),
(11, 'Lucas Ferreira', '121.121.121-12', '1994-05-02', '11 9999-0011', 'lucas.ferreira@example.com', 'Rua K, 1100'),
(12, 'Mariana Gomes', '131.131.131-13', '1996-10-11', '11 9999-0012', 'mariana.gomes@example.com', 'Rua L, 1200'),
(13, 'Felipe Ribeiro', '141.141.141-14', '1982-07-07', '11 9999-0013', 'felipe.ribeiro@example.com', 'Rua M, 1300'),
(14, 'Laura Mendes', '151.151.151-15', '1993-03-19', '11 9999-0014', 'laura.mendes@example.com', 'Rua N, 1400'),
(15, 'André Moreira', '161.161.161-16', '1978-12-02', '11 9999-0015', 'andre.moreira@example.com', 'Rua O, 1500');

-- inserindo 6 médicos (ids 16 a 21)
INSERT INTO pessoa(id, nome, cpf, data_nascimento, telefone, email, endereco) VALUES
(16, 'Paulo Araújo', '171.171.171-17', '1970-05-20', '11 9888-0001', 'paulo.araujo@example.com', 'Av Med, 10'),
(17, 'Beatriz Nascimento', '181.181.181-18', '1981-09-14', '11 9888-0002', 'beatriz.nascimento@example.com', 'Av Med, 20'),
(18, 'Victor Almeida', '191.191.191-19', '1969-02-28', '11 9888-0003', 'victor.almeida@example.com', 'Av Med, 30'),
(19, 'Camila Rodrigues', '202.202.202-20', '1986-11-09', '11 9888-0004', 'camila.rodrigues@example.com', 'Av Med, 40'),
(20, 'Thiago Santos', '212.212.212-21', '1990-04-18', '11 9888-0005', 'thiago.santos@example.com', 'Av Med, 50'),
(21, 'Daniela Alves', '222.222.222-22', '1987-12-30', '11 9888-0006', 'daniela.alves@example.com', 'Av Med, 60');

-- registrar como pacientes (tabela paciente)
INSERT INTO paciente(pessoa_id, numero_cartao, data_cadastro) VALUES
(1, 'PLANO-A-0001', '2024-01-10'),
(2, 'PLANO-A-0002', '2024-01-15'),
(3, 'PLANO-B-0003', '2024-02-01'),
(4, 'PLANO-A-0004', '2024-02-10'),
(5, 'PLANO-C-0005', '2024-03-05'),
(6, 'PLANO-B-0006', '2024-03-20'),
(7, 'PLANO-A-0007', '2024-04-10'),
(8, 'PLANO-C-0008', '2024-05-01'),
(9, 'PLANO-A-0009', '2024-06-15'),
(10, 'PLANO-B-0010', '2024-07-03'),
(11, 'PLANO-C-0011', '2024-07-20'),
(12, 'PLANO-A-0012', '2024-08-01'),
(13, 'PLANO-B-0013', '2024-08-10'),
(14, 'PLANO-C-0014', '2024-09-05'),
(15, 'PLANO-A-0015', '2024-09-20');

-- registrar como medicos (tabela medico)
INSERT INTO medico(pessoa_id, crm, especialidade) VALUES
(16, 'CRM-1001', 'Cardiologia'),
(17, 'CRM-1002', 'Clínica Geral'),
(18, 'CRM-1003', 'Ortopedia'),
(19, 'CRM-1004', 'Pediatria'),
(20, 'CRM-1005', 'Dermatologia'),
(21, 'CRM-1006', 'Oftalmologia');

-- inserir 20 consultas
INSERT INTO consulta(paciente_id, medico_id, data_consulta, observacoes) VALUES
(1, 16, '2025-01-10 09:00', 'Retorno para avaliação'),
(2, 16, '2025-01-15 10:30', 'Primeira consulta'),
(3, 17, '2025-02-05 11:00', 'Exame solicitado'),
(4, 18, '2025-02-10 14:00', 'Avaliação de coluna'),
(5, 17, '2025-03-01 08:30', 'Queixa de dor'),
(6, 16, '2025-03-15 09:45', 'Curativo'),
(7, 18, '2025-04-10 13:00', 'Radiografia solicitada'),
(1, 17, '2025-05-20 10:00', 'Retorno com exames'),
(8, 19, '2025-06-01 15:30', 'Acompanhamento'),
(9, 16, '2025-06-15 09:00', 'Vacinação'),
(10, 16, '2025-07-03 11:15', 'Consulta rotineira'),
(11, 17, '2025-07-20 12:00', 'Exames de rotina'),
(2, 17, '2025-08-01 10:00', 'Retorno do tratamento'),
(3, 18, '2025-08-10 14:30', 'Fisioterapia indicada'),
(4, 16, '2025-09-05 09:30', 'Reavaliação'),
(5, 19, '2025-09-12 16:00', 'Procedimento ambulatorial'),
(6, 17, '2025-09-20 10:30', 'Controle de medicação'),
(7, 16, '2025-10-01 08:45', 'Retorno pós-cirurgia'),
(8, 18, '2025-10-05 14:00', 'Consulta infantil'),
(1, 19, '2025-10-10 09:00', 'Consulta de emergência');
```

---

## 3 Atividades (passo a passo)

### Atividade 1 — Inspeção inicial

1. Conecte ao banco `plano_saude` e rode estas queries básicas:

```sql
SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';
SELECT count(*) FROM pessoa;
SELECT count(*) FROM paciente;
SELECT count(*) FROM medico;
SELECT count(*) FROM consulta;
```

2. Tire um print das saídas e anexe.

**Objetivo:** certificar-se do estado inicial e do volume de dados.


### Atividade 2 — Normalização do endereço (Pergunta 1)

**Tarefa:** decompor `pessoa.endereco` em colunas atômicas.

**Motivação:** facilita consultas por cidade/UF/CEP e validação de dados.

**Passos (execução):**

1. Verifique se há dados existentes em `endereco`:

```sql
SELECT id, nome, endereco FROM pessoa LIMIT 20;
```

2. Adicione novas colunas atômicas:

```sql
ALTER TABLE pessoa
  ADD COLUMN logradouro varchar(255),
  ADD COLUMN numero varchar(20),
  ADD COLUMN complemento varchar(100),
  ADD COLUMN bairro varchar(100),
  ADD COLUMN cidade varchar(100),
  ADD COLUMN uf char(2),
  ADD COLUMN cep varchar(9);
```

3. Migrar os dados existentes com SQL básico ou manualmente. Exemplo simples de separação quando o formato é homogêneo `Rua X, 100`:

```sql
UPDATE pessoa
SET logradouro = split_part(endereco, ',', 1),
    numero = trim(split_part(endereco, ',', 2));
```

4. Remover a coluna antiga após verificação:

```sql
ALTER TABLE pessoa DROP COLUMN endereco;
```

**Tarefa de avaliação:** insira prints do `SELECT nome, logradouro, numero, cidade, uf, cep FROM pessoa LIMIT 15;` mostrando que a decomposição foi aplicada.

---

### Atividade 3 — Normalização de especialidade (Pergunta 2)

**Tarefa:** criar tabela `especialidade` e referenciar `medico` por `especialidade_id`.

**Passos (execução):**

```sql
CREATE TABLE especialidade (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome varchar(100) NOT NULL UNIQUE
);

INSERT INTO especialidade (nome)
SELECT DISTINCT especialidade FROM medico WHERE especialidade IS NOT NULL;

ALTER TABLE medico ADD COLUMN especialidade_id int;

UPDATE medico m
SET especialidade_id = (
  SELECT id FROM especialidade e WHERE e.nome = m.especialidade
);

ALTER TABLE medico
  ADD CONSTRAINT fk_medico_especialidade FOREIGN KEY (especialidade_id)
    REFERENCES especialidade(id);

ALTER TABLE medico DROP COLUMN especialidade;
```

**Exercício:** anexe o print do `SELECT m.pessoa_id, p.nome, e.nome FROM medico m JOIN pessoa p ON m.pessoa_id = p.id JOIN especialidade e ON m.especialidade_id = e.id;` mostrando a migração.

---

### Atividade 4 — Limpeza e padronização de CPF e telefone (Pergunta 3)

**Tarefa:** remover máscaras de CPF e telefone, alterar tipos e aplicar `CHECK`.

**Motivação:** o banco deve armazenar dados em forma canônica (sem máscara), a formatação fica a cargo da aplicação.

**Passos (execução):**

1. Limpar CPF (remover pontos e traços e quaisquer caracteres não numéricos)

```sql
UPDATE pessoa
SET cpf = regexp_replace(cpf, '[^0-9]', '', 'g');
```

> Antes de alterar o tipo, cheque se todos os CPFs têm 11 dígitos e se não existem duplicatas após a limpeza (veja as checagens recomendadas mais abaixo).

2. Converter tipo para `char(11)` (exemplo)

```sql
-- Só execute após as checagens e correções necessárias
ALTER TABLE pessoa ALTER COLUMN cpf TYPE char(11)
  USING lpad(regexp_replace(cpf, '[^0-9]', '', 'g'), 11, '0');
```

3. Adicionar constraint de formato:

```sql
ALTER TABLE pessoa ADD CONSTRAINT chk_cpf_formato CHECK (cpf ~ '^[0-9]{11}$');
```

4. Telefone: limpar não numéricos e alterar tipo para `varchar(15)`:

```sql
UPDATE pessoa SET telefone = regexp_replace(telefone, '[^0-9]', '', 'g');
ALTER TABLE pessoa ALTER COLUMN telefone TYPE varchar(15)
  USING regexp_replace(telefone, '[^0-9]', '', 'g');
```

**Exercício:** mostrem prints do `SELECT id, nome, cpf, telefone FROM pessoa;` após limpeza.

---

### Atividade 5 — Email: UNIQUE e CHECK (Pergunta 4)

**Tarefa:** garantir unicidade e formato mínimo do email.

**Passos (execução):**

1. Verificar duplicatas e entradas inválidas antes de aplicar constraints:

```sql
SELECT email, count(*) FROM pessoa GROUP BY email HAVING count(*) > 1;
SELECT * FROM pessoa WHERE email !~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$';
```

2. Corrigir manualmente os registros inválidos (se existir) e depois aplicar constraints:

```sql
ALTER TABLE pessoa ADD CONSTRAINT uq_pessoa_email UNIQUE (email);
ALTER TABLE pessoa ADD CONSTRAINT chk_email_formato CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');
```

**Exercício:** anexem prints das checagens e do `ALTER TABLE` bem sucedido.

---

### Atividade 6 — Regras de negócio: evitar dupla marcação de consultas (Pergunta 5)

**Tarefa:** garantir que um mesmo médico não tenha duas consultas no mesmo `timestamp`.

**Solução simples:** adicionar `UNIQUE (medico_id, data_consulta)`.

```sql
ALTER TABLE consulta ADD CONSTRAINT uq_medico_agendamento UNIQUE (medico_id, data_consulta);
```

**Exercício:** tentem inserir uma consulta duplicada (com mesmo medico_id e data_consulta) para provar que a restrição bloqueia a operação e anexem o print do erro.

---

### Atividade 7 — Perguntas de verificação (Queries) (Pergunta 6)

**Tarefa:** listar médicos sem consultas.

```sql
-- LEFT JOIN
SELECT p.nome, m.crm
FROM medico m
JOIN pessoa p ON m.pessoa_id = p.id
LEFT JOIN consulta c ON m.pessoa_id = c.medico_id
WHERE c.id IS NULL;

-- NOT EXISTS
SELECT p.nome, m.crm
FROM medico m
JOIN pessoa p ON m.pessoa_id = p.id
WHERE NOT EXISTS (
  SELECT 1 FROM consulta c WHERE c.medico_id = m.pessoa_id
);
```

**Tarefa:** listar pacientes sem consultas. também

**Exercício:** capture os resultados e anexe.

---

### Atividade 8 — Restrições `NOT NULL` e regras de obrigatoriedade

**Tarefa:** aplicar `NOT NULL` onde fizer sentido de acordo com a regra de negócio.

Sugestões a aplicar (com justificativa requerida):

- `pessoa.cpf` — se o CPF for requisito do sistema
- `pessoa.data_nascimento` — importante para cálculo de idade e regras do plano
- `paciente.numero_cartao` — `NOT NULL` e `UNIQUE` (identificação do beneficiário)
- `medico.crm` — `NOT NULL` e `UNIQUE` (identificação profissional)

```sql
ALTER TABLE paciente ALTER COLUMN numero_cartao SET NOT NULL;
ALTER TABLE paciente ADD CONSTRAINT uq_paciente_numero_cartao UNIQUE (numero_cartao);
ALTER TABLE medico ALTER COLUMN crm SET NOT NULL;
ALTER TABLE medico ADD CONSTRAINT uq_medico_crm UNIQUE (crm);
ALTER TABLE pessoa ALTER COLUMN data_nascimento SET NOT NULL;
```

**Observação importante:** antes de aplicar `SET NOT NULL` ou `UNIQUE` garanta que não existam registros violando essa restrição.

---

## 4 Pré-checagens

Exemplos úteis:

```sql
-- CPFs que não têm 11 dígitos após limpeza
SELECT id, cpf FROM pessoa WHERE length(regexp_replace(cpf, '[^0-9]', '', 'g')) != 11;

-- Duplicatas de CPF após limpeza
SELECT regexp_replace(cpf, '[^0-9]', '', 'g') as cpf_clean, count(*)
FROM pessoa GROUP BY cpf_clean HAVING count(*) > 1;

-- Emails duplicados
SELECT email, count(*) FROM pessoa GROUP BY email HAVING count(*) > 1;

-- Telefone com mais de 15 dígitos ou vazio
SELECT id, telefone FROM pessoa WHERE telefone IS NULL OR length(telefone) > 15;
```

---

## 5 Índices e observações sobre performance

Os índices originais criados são adequados para joins e pesquisas por data:

- `idx_consulta_paciente` (consulta.paciente_id)
- `idx_consulta_medico` (consulta.medico_id)
- `idx_consulta_data` (consulta.data_consulta)

---

## 6 Foreign keys e `ON DELETE`

O uso de `ON DELETE RESTRICT` em `consulta` é para impedir exclusão de paciente/medico com consultas registradas. Isso é coerente com muitos requisitos de negócio.
Alternativa: `ON DELETE CASCADE` que apaga consultas relacionadas automaticamente se um paciente/medico for removido.

---

## 7 Testes e validação final

1. Rodem queries para confirmar integridade e contagens:

```sql
SELECT count(*) FROM paciente;
SELECT count(*) FROM consulta;

SELECT * FROM pessoa WHERE cpf IS NULL OR cpf !~ '^[0-9]{11}$';
SELECT * FROM medico WHERE crm IS NULL;
```

2. Insiram uma consulta que viole `UNIQUE (medico_id, data_consulta)` para provar a restrição.
3. Testem a listagem de médicos sem consultas.

Anexem prints dessas verificações.

---

## 8 Checklist de entrega

1. Print: estado inicial (contagens) antes das alterações
2. Print: resultados da decomposição do endereço
3. Print: migração e criação de `especialidade` e atualização de `medico`
4. Print: limpeza e alteração de `cpf` e `telefone`
5. Print: aplicação dos constraints (`UNIQUE`, `CHECK`, `NOT NULL`)
6. Print: tentativa de inserir consulta duplicada e erro gerado
7. Print: resultado da query que lista médicos sem consultas
8. Print: resultado da query que lista pacientes sem consultas

---